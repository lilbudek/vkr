\chapter{ПРОЕКТИРОВАНИЕ}
\section{Моделирование DDS}
Для начала потребуется таблица отсчётов, чтобы её вычислить используем готовый инструмент~\cite{lut}.
	
	\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{../image/lut_prog.png}
    \caption{Программа для вычисления значений сигнала.}
	\end{figure}
	
	У таблицы есть 4 параметра:
	\begin{enumerate}
		\item Разрядность ЦАП: 8 или 12 бит.
		\item Максимальное значение.
		\item Количество значений.
		\item Смещение от нуля.
	\end{enumerate}
	
	Использовать мы будем 12-битные значения в количестве 256 чисел. Максимальное значение амплитуды сигнала может быть 4095.%, но так как для улучшения генерации будет задействован встроенный в цифро-аналоговый преобразователь выходной буфер, то он будет срезать сигнал сверху и снизу на 0.2В, поэтому значения тоже следует срезать на эту же величину для корректной генерации.
	
%	В документе от ST про работу с цифро-аналоговым преобразователем есть формула для расчета выходного напряжения.
	
%	$DAC_{output} = V_{REF}*\dfrac{DOR}{DAC_{MaxDigitalValue} + 1}$, где DOR --- цифровое значение.
	
%	Нам нужно найти какое значение соответствует напряжению 0.2В. Выразим DOR и подставим имеющиеся значения.
	
%	$DOR = \dfrac{V_{REF}}{DOR}*DAC_{MaxDigitalValue} + 1 = \dfrac{3.3}{0.2}*(4095+1) = 248$
	
%	Укажем смещение от нуля 248, а максимальное значение 4095 меньше на 248, то есть 3847 и сгенеририуем таблицу отсчётов для синусоиды. 
	
	\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{../image/lut.png}
    \caption{Вычисление таблицы сигнала.}
	\end{figure}
	
	Теперь у нас есть данные для генерации сигнала. Смоделируем алгоритм метода прямого цифрового синтеза по блок-схеме на рис. 1.15 на языке Си для дальнейшей реализации на микроконтроллере.

\begin{code}
\captionof{listing}{Метод DDS.}
\begin{minted}[mathescape,linenos,frame=lines,breaklines]{text}
int main() {
  uint16_t p_acc, p_step;
  uint8_t addr = 0; // адрес ячейки

  p_acc = 0;    // аккумулятор фазы
  p_step = 128; // код частоты

  while(1)
  {
    addr = p_acc >> 8; // выделение старшей части аккумулятора фазы
    p_acc += p_step;   // шаг
    printf("%d 0x%X\n", addr, sinus[addr]); // вывод отсчёта
  }

  return 0;
}
\end{minted}
\end{code}

	
	Код частоты задаёт выходную частоту генератора. При значении 256 вывод будет следующий:
	
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{../image/dds256.png}
    \caption{Формирование отсчётов при коде частоты 256.}
\end{figure}
	
	Увеличим код частоты в два раза и получим следующее:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{../image/dds512.png}
    \caption{Формирование отсчётов при коде частоты 512.}
\end{figure}

	Как можно заметить отсчёты стали формироваться через один, соответственно частота вырастит в два раза. Теперь уменьшим частоту в два раза выставив код частоты 128.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{../image/dds128.png}
    \caption{Формирование отсчётов при коде частоты 128.}
\end{figure}

	Программа стала выводить каждый отсчёт по два раза тем самым, понизив частоту.
	
	В данном виде модуляции код частоты просто абстрактное число, которое добавляется к аккумулятору фазы и узнать реальную частоту проблематично. Результат синтеза будет проверен опытным путём на микроконтроллере.
	
\section{Обзор микроконтроллеров}
	Так как генератор сигналов будет реализовываться на микроконтроллере следует провести обзор и осуществить выбор. Рассмотрим два популярных семейства микроконтроллеров AVR и STM32.
\subsection{AVR}
	Микроконтроллеры AVR --- это 8-разрядные микроконтроллеры с архитектурой RISC. Данное семейство представляет собой хорошую основу для создания высокопроизводительных и экономичных встраиваемых систем~\cite{avr}. Подразделяется семейство на две группы: Tiny и Mega.
	
	Микроконтроллеры Tiny имеют небольшую память для программ и их периферия ограничена. Большинство микроконтроллеров данной серии выпускаются в 8-выводных корпусах и предназначены для систем с ограниченным бюджетом. Областью их применения являются различные датчики и бытовая техника~\cite{avr}.
	
	Группа Mega наоборот имеет большую память и развитую периферию. Соответственно область применения гораздо шире и предназначены они для более сложных систем. В таблице 2.1 приведены серии микроконтроллеров и коротко описан их приоритет.

\begin{table}[H]
\caption{Микроконтроллеры AVR.}
\begin{tabular}{|p{3.25 cm}|p{8 cm}|p{4 cm}|}
\hline
Группа & Приоритет & Название серий \\ \hline
Tiny & Энергоэффективность, компактность, низкая стоимость & tiny1, tiny2, tiny4, tiny8 \\ \hline
Mega & Производительность, гибкость & mega4, mega8, mega16, mega32, mega64, mega128, mega256 \\ \hline
\end{tabular}
\end{table}

\subsection{STM32}
	Микроконтроллеры STM32 --- это 32-разрядные микроконтроллеры, имеющие процессорное ядро с архитектурой ARM Cortex-M. В настоящее время существует множество микроконтроллеров STM32. Они делятся на семейства в зависимости от версии архитектуры (табл. 2.2).

\begin{table}[H]
\caption{Семейства STM32.}
\begin{tabular}{|p{4 cm}|p{4 cm}|}
\hline
Серия & Ядро \\ \hline
F0  & Cortex-М0 \\ \hline
G0, L0  & Cortex-М0+ \\ \hline
F1, F2  & Cortex-М3 \\ \hline
F3, F4, L4, G4  & Cortex-М4 \\ \hline
F7, H7  & Cortex-М7 \\ \hline
\end{tabular}
\end{table}

	Ядро Cortex-M обеспечивает программную совместимость во всех семействах. Кроме этого, для микроконтроллеров выпущенных в одинаковых корпусах присутствует и аппаратная совместимость, так как на выводах сохраняются одни и те же функции~\cite{stm}. Будем рассматривать серии микроконтроллеров схожие по функциональным возможностям с Tiny и Mega для дальнейшего сравнения. В таблице 2.3 указаны серии STM32 по группам.
	
\begin{table}[H]
\caption{Микроконтроллеры STM32.}
\begin{tabular}{|p{3.25 cm}|p{8 cm}|p{4 cm}|}
\hline
Группа & Приоритет & Название серий \\ \hline
Широкого применения & Баланс между производительностью и энергоэффективностью & F0, G0, F1, F3,
G4 \\ \hline
Сверхнизкого энергопотребления & Энергоэффективность, компактность, низкая стоимость & L0, L4 \\ \hline
\end{tabular}
\end{table}

\section{Сравнение семейств AVR и STM32}
	
	Для осуществления выбора проведём сравнение микроконтроллеров, взяв параметры наиболее используемых серий из каждой группы (табл. 2.4).
	
\begin{table}[H]
\caption{Параметры микроконтроллеров.}
\begin{tabular}{|p{2.5 cm}|p{3 cm}|p{3 cm}|p{3 cm}|p{3 cm}|}
\hline
        Параметр & ATtiny1 & ATmega32 & STM32L010 & STM32F103 \\ \hline
        Частота & 20 МГц & 20 МГц & 32 МГц & 72 МГц \\ \hline
        FLASH & 1 Кбайт & 32 Кбайт & 16 Кбайт & 64 Кбайт \\ \hline
        RAM & 64 байт & 2 Кбайт & 2 Кбайт & 20 Кбайт \\ \hline
        SPI & - & + & + & + \\ \hline
        I2C & - & +	 & + & + \\ \hline
        Питание & 1,8 --- 5,5 В & 1,8 --- 5,5 В & 1,8 --- 3,6 В & 1,8 --- 3,6 В \\ \hline
\end{tabular}
\end{table}
	
	Исходя из таблицы можно сделать вывод, что микроконтроллеры AVR применимы в малом спектре задач где скорость не так важна. В нашем же случае скорость работы микроконтроллера может сильно влиять на генерацию сигнала, а также требуется объём памяти для хранения отсчётов сигналов. В микроконтроллерах STM32 с частотой и объёмом памяти проблем нет и они имеют широкое применение. Серию же выберем F103 за её характеристики. В связи с этим в устройстве будет применён микроконтроллер STM32F103RCT6.

\section{Среды разработки для STM32}

	Среда разработки является не маловажным инструментом для создания программной части устройства. В связи с выбором микроконтроллера STM32 рассмотрим популярные бесплатные среды для создания программы на этом семействе микроконтроллеров.

\subsection{STM32CubeIDE}
	STM32CubeIDE --- это продвинутая платформа разработки на C/C++ с функциями настройки периферийных устройств, генерации кода, компиляции кода и отладки для микроконтроллеров и микропроцессоров STM32~\cite{cube}. Среда разработки основана на платформе Eclipse и GCC toolchain для разработки и GDB для отладки. Она позволяет интегрировать сотни существующих плагинов, которые дополняют возможности Eclipse IDE. Имеет расширенные функции отладки, включая: просмотр ядра ЦП, регистров периферийных устройств и памяти, анализ системы просмотра переменных в режиме реального времени. Поддерживается на операционных системах: Linux, macOS, Windows.

	\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{../image/cube.jpg}
    \caption{Интерфейс STM32CubeIDE.}
	\end{figure}
	
	После выбора микроконтроллера STM32 создается проект и генерируется код инициализации. В любой момент разработки пользователь может вернуться к инициализации и настройке периферийных устройств и повторно создать код инициализации без какого-либо влияния на пользовательский код. Для разработки используется библиотека HAL. 
	
	Драйверы HAL включают в себя полный набор готовых к использованию функций, которые упрощают реализацию пользовательских приложений. Например, коммуникационные периферийные устройства содержат функции для инициализации и настройки периферийного устройства, управления передачей данных, обработки прерываний или DMA~\cite{hal}.
	
	Достоинства:
	\begin{itemize}
		\item Поддержка различных ОС.
		\item Расширенные возможности отладки.
		\item Большое сообщество.
		\item Автогенерация кода.
	\end{itemize}
	
	Недостатки:
	\begin{itemize}
		\item Требовательность к ресурсам ПК.
		\item Сложность настройки.
	\end{itemize}

\subsection{PlatformIO}

	PlatformIO --- удобная и расширяемая интегрированная среда разработки с набором профессиональных инструментов разработки, предоставляющая современные и мощные функции для ускорения и упрощения процесса разработки встраиваемых продуктов~\cite{plio}.
	
	\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{../image/plio.jpg}
    \caption{Интерфейс PlatformIO.}
	\end{figure}
	
	Данная среда разработки является расширением для текстового редактора Visual Studio Code. VS Code --- это легкий, но мощный редактор кода, имеющий богатую экосистему расширений~\cite{docsplio}. Доступен для Windows, macOS и Linux. Работа в паре с VS Code позволяет удобно форматировать код и пользоваться расширениями для языков программирования.
	
	PlatformIO позволяет работать со многими микроконтроллерами и поддерживает множество фреймворков для них, а также библиотек. Ввиду такой широкой поддержки, для STM32 можно разрабатывать с удобной для себя библиотекой. Это может быть к примеру тот же HAL, что и в STM32CubeIDE или libopencm3. Проект libopencm3 (ранее известный как libopenstm32) направлен на создание бесплатной библиотеки микропрограмм с открытым исходным кодом (LGPL версии 3 или более поздней) для различных микроконтроллеров ARM Cortex-M3, включая ST STM32~\cite{lcm3}.


	Достоинства:
	\begin{itemize}
		\item Поддержка различных ОС.
		\item Быстрая компиляция.
		\item Поддержка GitHub.
		\item Возможность работать с разными фрэймворками и платформами.
	\end{itemize}
	
	Недостатки:
	\begin{itemize}
		\item Высокий порог вхождения.
		\item Сложность установки.
	\end{itemize}

	Попользовавшись обеими средами разработки и разными библиотеками, а также основываясь на достоинствах и недостатках была выбрана среда разработки PlatformIO в связке с библиотекой libopencm3.


\section{Алгоритм работы}

	Программа должна выполнять три действия:
	
	\begin{enumerate}
		\item Вывод отсчёта в ЦАП.
		\item Обработка кнопок.
		\item Вывод информации на дисплей.
	\end{enumerate}
	
	Для цифро-аналогового преобразователя и кнопок выделим два таймера общего назначения, а работа с дисплеем будет идти в главном цикле программы. Применив такой подход, удастся добиться асинхронного выполнения программы. 
	
	Таким образом, для подпрограммы генерации сигнала будет следующая блок-схема.
	
	\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{../image/dac.pdf}
    \caption{Блок-схема функции ЦАП.}
	\end{figure}
	
	По созданной блок-схеме код 
	
\begin{code}
\captionof{listing}{Генерация сигнала.}
\begin{minted}[mathescape,linenos,frame=lines,breaklines]{text}
void tim2_isr(void) // обработчик прерывания таймера2 (ЦАП)
{
    dac_load_data_buffer_single(signal[p_acc >> 8], RIGHT12, CHANNEL_2); // загрузка буфера в цап
    p_acc += p_step;             // шаг
    TIM_SR(TIM2) &= ~TIM_SR_UIF; // очистка флага прерывания
}
\end{minted}
\end{code}
	
	Обработка кнопок представлена следующей блок-схемой.	
	
	\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{../image/buttons.pdf}
    \caption{Блок-схема функции кнопок.}
	\end{figure}
	
	Подпрограмма обработки кнопок находится в обработчике прерывания таймера номер 3. Таймер настроен на период 250 миллисекунд. Благодаря такой организации, решается проблема дребезга кнопок. Не приходится делать программную или аппаратную задержку для ожидания установки состояния кнопки.

\begin{code}
\captionof{listing}{Обработка кнопок.}
\begin{minted}[mathescape,linenos,frame=lines,breaklines]{text}
void tim3_isr(void) // обработчик прерывания таймера3 (обработка кнопок)
{
    minus_freq();
    plus_freq();
    minus_signal(); // функции кнопок
    plus_signal();
    step_select();
    TIM_SR(TIM3) &= ~TIM_SR_UIF; // очистка флага прерывания
}
\end{minted}
\end{code}


\section{Вывод из второй главы}
